# 1. Chocolate Distribution Problem
def find_min_diff(arr, m):
    if m == 0 or len(arr) == 0:
        return 0
    if len(arr) < m:
        return -1
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr) - m + 1):
        diff = arr[i + m - 1] - arr[i]
        if diff < min_diff:
            min_diff = diff
    return min_diff

# 2. Smallest subarray with sum greater than x
def smallest_subarray_with_sum(arr, x):
    n = len(arr)
    min_len = n + 1
    start, end, current_sum = 0, 0, 0
    
    while end < n:
        while current_sum <= x and end < n:
            current_sum += arr[end]
            end += 1
        while current_sum > x and start < n:
            if end - start < min_len:
                min_len = end - start
            current_sum -= arr[start]
            start += 1
            
    return min_len if min_len != n + 1 else 0

# 3. Three-way partitioning
def three_way_partition(arr, a, b):
    low, mid, high = 0, 0, len(arr) - 1
    while mid <= high:
        if arr[mid] < a:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] > b:
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1
        else:
            mid += 1
    return arr

# 4. Minimum swaps required to bring all elements less than or equal to k together
def min_swaps(arr, k):
    n = len(arr)
    count = sum(1 for x in arr if x <= k)
    
    bad = sum(1 for i in range(count) if arr[i] > k)
    ans = bad
    
    for i in range(0, n - count):
        if arr[i] > k:
            bad -= 1
        if arr[i + count] > k:
            bad += 1
        ans = min(ans, bad)
        
    return ans

# 5. Palindromic Array
def is_palindromic_array(arr):
    for num in arr:
        s = str(num)
        if s != s[::-1]:
            return False
    return True

# 6. Find the median
def find_median(arr):
    arr.sort()
    n = len(arr)
    if n % 2 != 0:
        return float(arr[n // 2])
    else:
        return (arr[(n - 1) // 2] + arr[n // 2]) / 2.0

# 7. Spirally traversing a matrix
def spirally_traverse(mat):
    result = []
    if not mat:
        return result
    top, bottom = 0, len(mat) - 1
    left, right = 0, len(mat[0]) - 1
    
    while top <= bottom and left <= right:
        for i in range(left, right + 1):
            result.append(mat[top][i])
        top += 1
        for i in range(top, bottom + 1):
            result.append(mat[i][right])
        right -= 1
        if top <= bottom:
            for i in range(right, left - 1, -1):
                result.append(mat[bottom][i])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(mat[i][left])
            left += 1
            
    return result

# 8. Search a 2D Matrix (LeetCode)
def search_matrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_val = matrix[mid // n][mid % n]
        
        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return False

# 9. Median in a row-wise sorted matrix
def median_in_matrix(mat):
    from bisect import bisect_right
    r, c = len(mat), len(mat[0])
    min_val, max_val = float('inf'), float('-inf')
    
    for i in range(r):
        min_val = min(min_val, mat[i][0])
        max_val = max(max_val, mat[i][c-1])
        
    desired = (r * c + 1) // 2
    
    while min_val < max_val:
        mid = min_val + (max_val - min_val) // 2
        place = 0
        for i in range(r):
            place += bisect_right(mat[i], mid)
            
        if place < desired:
            min_val = mid + 1
        else:
            max_val = mid
            
    return min_val

# 10. Row with max 1s
def row_with_max_1s(arr):
    if not arr or not arr[0]:
        return -1
    r, c = len(arr), len(arr[0])
    max_row_index = -1
    j = c - 1
    
    for i in range(r):
        while j >= 0 and arr[i][j] == 1:
            j -= 1
            max_row_index = i
            
    return max_row_index
